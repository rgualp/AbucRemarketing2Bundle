<?php

namespace MyCp\PartnerBundle\Repository;

use Doctrine\ORM\EntityRepository;
use MyCp\PartnerBundle\Entity\paGeneralReservation;
use MyCp\PartnerBundle\Entity\paOwnershipReservation;

/**
 * paGeneralReservationRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class paGeneralReservationRepository extends EntityRepository {

    public function createReservationForPartner($user, $accommodation, $dateFrom, $dateTo, $adults, $children, $container, $translator, $rooms = null, $roomType = null, $roomsTotal = null)
    {
        $em = $this->getEntityManager();
        $service_time = $container->get("Time");
        $serviceFee = $em->getRepository("mycpBundle:serviceFee")->getCurrent();

        $nights = $service_time->nights($dateFrom->getTimestamp(), $dateTo->getTimestamp());

        $general_reservation = new paGeneralReservation();
        $general_reservation->setUser($user);
        $general_reservation->setCreationDate(new \DateTime(date('Y-m-d')));
        $general_reservation->setHour(new \DateTime(date('H:i:s')));
        $general_reservation->setDateFrom($dateFrom);
        $general_reservation->setDateTo($dateTo);
        $general_reservation->setAccommodation($accommodation);
        $general_reservation->setServiceFee($serviceFee);
        $general_reservation->setNights($nights);

        $total_price = 0;
        $partial_total_price = array();
        $destination_id = ($accommodation->getOwnDestination() != null) ? $accommodation->getOwnDestination()->getDesId() : null;

        $availability = $this->getAvailableRooms($accommodation, $dateFrom, $dateTo, $roomType);
        $rooms = $availability["availableRooms"];

        if(count($rooms) == 0)
            return array("successful" => false, "message" => $translator->trans("MSG_ERROR_NO_ROOMS_AVAILABLE"), "reservation" => null);

        if($roomsTotal != null && $roomsTotal >  count($rooms))
            return array("successful" => false, "message" => $translator->trans("MSG_ERROR_NO_VALID_TOTAL_GUESTS"), "reservation" => null);

        $isAValidTotalGuests = $this->checkCapacity($availability["availableCapacity"], $adults, $children);

        if(!$isAValidTotalGuests)
            return array("successful" => false, "message" => $translator->trans("MSG_ERROR_NO_VALID_TOTAL_GUESTS"), "reservation" => null);

        $adultsCounter = $adults*1;
        $childrenCounter = $children*1;


        if($roomsTotal != null and $roomsTotal > 0) //Algoritmo que ubica hasta completar el total de habitaciones solicitadas
        {
            $selectedRooms = array();
            $roomsCounter = 0;

            foreach($rooms as $room)
            {
                if($roomsCounter == $roomsTotal) break;

                $selectedRooms[] = array(
                    "roomId" => $room->getRoomId(),
                    "maxCapacity" => $room->getMaximumNumberGuests(),
                    "adults" => 0,
                    "children" => 0
                );
            }

            //Ubica de uno en uno por todas las habitaciones hasta completar la cantidad solicitada
            while($adultsCounter > 0 || $childrenCounter > 0){
                for($i = 0; $i < count($selectedRooms); $i++)
                {
                    if($adultsCounter <= 0 && $childrenCounter <= 0) break;
                    $capacityLodged = ($selectedRooms[$i]["adults"] + $selectedRooms[$i]["children"]) / 2;

                    if($capacityLodged < $selectedRooms[$i]["maxCapacity"])
                    {
                        if($adultsCounter > 0) {
                            $selectedRooms[$i]["adults"] = $selectedRooms[$i]["adults"] + 1;
                            $adultsCounter--;
                        }

                        if($childrenCounter > 0) {
                            $selectedRooms[$i]["children"] = $selectedRooms[$i]["children"] + 1;
                            $childrenCounter--;
                        }
                    }
                }
            }

            //Recorrer las habitaciones con la cantidad ubicada, para crear las reservas
            foreach($selectedRooms as $selectedRoom)
            {
                $room = $em->getRepository("mycpBundle:room")->find($selectedRoom["roomId"]);
                $adultsToLodge = $selectedRoom["adults"];
                $childrenToLodge = $selectedRoom["children"];

                $triple_room_recharge = (($adultsToLodge + $childrenToLodge) >= 3) ? $container->getParameter('configuration.triple.room.charge') : 0;
                $array_dates = $service_time->datesBetween($dateFrom->getTimestamp(), $dateTo->getTimestamp());
                $temp_price = 0;

                $seasons = $em->getRepository("mycpBundle:season")->getSeasons($dateFrom->getTimestamp(), $dateTo->getTimestamp(), $destination_id);

                for ($a = 0; $a < count($array_dates) - 1; $a++) {
                    $seasonType = $service_time->seasonTypeByDate($seasons, $array_dates[$a]);
                    $roomPrice = $room->getPriceBySeasonType($seasonType);
                    $total_price += $roomPrice + $triple_room_recharge;
                    $temp_price += $roomPrice + $triple_room_recharge;
                }
                $partial_total_price[$room->getRoomId()] = $temp_price;

                $ownership_reservation = new paOwnershipReservation();
                $ownership_reservation->setAdults($adultsToLodge);
                $ownership_reservation->setChildren($childrenToLodge);
                $ownership_reservation->setDateFrom($dateFrom);
                $ownership_reservation->setDateTo($dateTo);
                $ownership_reservation->setRoom($room);
                $ownership_reservation->setRoomPriceDown($room->getRoomPriceDownTo());
                $ownership_reservation->setRoomPriceUp($room->getRoomPriceUpTo());
                $ownership_reservation->setRoomPriceSpecial($room->getRoomPriceSpecial());
                $ownership_reservation->setPaGenResId($general_reservation);
                $ownership_reservation->setRoomType($room->getRoomType());
                $ownership_reservation->setTotalPrice($partial_total_price[$room->getRoomId()]);
                $ownership_reservation->setNights($nights);

                $em->persist($ownership_reservation);
            }
        }
        else{ //Algoritmo gloton. Siempre ubicara la cantidad maxima de una habitacion

            foreach ($rooms as $room) {
            if($adultsCounter <= 0 && $childrenCounter <= 0) break;

            $adultsToLodge = $room->getMaximumNumberGuests();
            $childrenToLodge = $adultsToLodge;

            if($adultsCounter > 0 && $adultsCounter < $adultsToLodge)
                $adultsToLodge = $adultsCounter;

            if($childrenCounter >= 0 && $childrenCounter < $childrenToLodge)
                $childrenToLodge = $childrenCounter;

            $adultsCounter -= $adultsToLodge;
            $childrenCounter -= $childrenToLodge;

            $triple_room_recharge = (($adultsToLodge + $childrenToLodge) >= 3) ? $container->getParameter('configuration.triple.room.charge') : 0;
            $array_dates = $service_time->datesBetween($dateFrom->getTimestamp(), $dateTo->getTimestamp());
            $temp_price = 0;

            $seasons = $em->getRepository("mycpBundle:season")->getSeasons($dateFrom->getTimestamp(), $dateTo->getTimestamp(), $destination_id);

            for ($a = 0; $a < count($array_dates) - 1; $a++) {
                $seasonType = $service_time->seasonTypeByDate($seasons, $array_dates[$a]);
                $roomPrice = $room->getPriceBySeasonType($seasonType);
                $total_price += $roomPrice + $triple_room_recharge;
                $temp_price += $roomPrice + $triple_room_recharge;
            }
            $partial_total_price[$room->getRoomId()] = $temp_price;

            $ownership_reservation = new paOwnershipReservation();
            $ownership_reservation->setAdults($adultsToLodge);
            $ownership_reservation->setChildren($childrenToLodge);
            $ownership_reservation->setDateFrom($dateFrom);
            $ownership_reservation->setDateTo($dateTo);
            $ownership_reservation->setRoom($room);
            $ownership_reservation->setRoomPriceDown($room->getRoomPriceDownTo());
            $ownership_reservation->setRoomPriceUp($room->getRoomPriceUpTo());
            $ownership_reservation->setRoomPriceSpecial($room->getRoomPriceSpecial());
            $ownership_reservation->setPaGenResId($general_reservation);
            $ownership_reservation->setRoomType($room->getRoomType());
            $ownership_reservation->setTotalPrice($partial_total_price[$room->getRoomId()]);
            $ownership_reservation->setNights($nights);

            $em->persist($ownership_reservation);
        }
        }

        $general_reservation->setTotalPrice($total_price);

        $em->persist($general_reservation);
        $em->flush();


        return array("successful" => true, "message" => null, "reservation" => $general_reservation);
    }

    public function getAvailableRooms($accommodation, $dateFrom, $dateTo, $roomType = null)
    {
        $em = $this->getEntityManager();
        //$rooms = $accommodation->getOwnRooms();

        //Seleccionar las habitaciones del alojamiento solo del tipo seleccionado en los filtros
        $qb = $em->createQueryBuilder()
            ->from("mycpBundle:room", "r")
            ->select("r")
            ->where("r.room_ownership = :ownId")
            ->setParameter("ownId", $accommodation->getOwnId());

        if($roomType != null)
            $qb->andWhere("r.room_type = :roomType")
               ->setParameter("roomType", $roomType);

        $rooms = $qb->getQuery()->getResult();

        $capacity = 0;

        $returnedRooms = array();


        foreach($rooms as $room)
        {
            $uDetailsCount = $em->getRepository("mycpBundle:unavailabilityDetails")->existByDateAndRoom($room->getRoomId(), $dateFrom, $dateTo);
            $reservations = $em->getRepository("mycpBundle:ownershipReservation")->getCountReservationsByRoomAndDates($room->getRoomId(), $dateFrom, $dateTo);

            if(($uDetailsCount + $reservations) == 0)
            {
                $returnedRooms[] = $room;
                $capacity += $room->getMaximumNumberGuests();
            }
        }

        return array("availableRooms" => $returnedRooms, "availableCapacity" => $capacity);
    }

    private function checkCapacity($totalCapacity, $adults, $children)
    {
        $maxGuests = ($adults > $children) ? $adults : $children;
        return $totalCapacity >= $maxGuests;
    }

    function getReservationsPartner($idUser, array $filters, $start, $limit)
    {
        $qb = $this->createQueryBuilder('r');

        $qb->join('r.user', 'u');
        $qb->andWhere('u.user_id = :user_id');
        $qb->setParameter('user_id', $idUser);

        $qb->join('r.travelAgencyOpenReservationsDetails', 'pard');
        $qb->join('pard.reservation', 'par');
        $qb->join('par.client', 'client');

        $qb->orderBy("r.id", "DESC");

        if (isset($filters)) {
            $code = (array_key_exists('code', $filters) && isset($filters['code']));
            $own_name = (array_key_exists('own_name', $filters) && isset($filters['own_name']));
            $from = (array_key_exists('from', $filters) && isset($filters['from']));
            $to = (array_key_exists('to', $filters) && isset($filters['to']));
            $date = (array_key_exists('date', $filters) && isset($filters['date']));
            $destination = (array_key_exists('destination', $filters) && isset($filters['destination']));
            $client_dates = (array_key_exists('client_dates', $filters) && isset($filters['client_dates']));

            if ($own_name || $code || $destination) {
                $qb->join('r.accommodation', 'o');

                if ($own_name) {
                    $qb->andWhere('o.own_name LIKE :own_name');
                    $qb->setParameter('own_name', '%' . trim($filters['own_name']) . '%');
                }
                if ($code) {
                    $qb->andWhere('o.own_mcp_code LIKE :own_mcp_code');
                    $qb->setParameter('own_mcp_code', '%' . trim($filters['code']) . '%');
                }
                if ($destination) {
                    $qb->join('o.own_destination', 'd');
                    $qb->andWhere('d.des_id = :des_id');
                    $qb->setParameter('des_id', $filters['destination']);
                }
            }
            if ($from) {
                $qb->andWhere('r.dateFrom = :gen_res_from_date');
                $qb->setParameter('gen_res_from_date', Dates::createForQuery($filters['from'], 'd-m-Y'));
            }
            if ($to) {
                $qb->andWhere('r.dateTo = :gen_res_to_date');
                $qb->setParameter('gen_res_to_date', Dates::createForQuery($filters['to'], 'd-m-Y'));
            }
            if ($date) {
                $qb->andWhere('r.creationDate = :gen_res_date');
                $qb->setParameter('gen_res_date', Dates::createForQuery($filters['date'], 'd-m-Y'));
            }
            if ($client_dates) {
                $qb->andWhere('client.fullname LIKE :client_dates');
                $qb->setParameter('client_dates', '%' . trim($filters['client_dates']) . '%');
            }
        }

        $qbAux = clone $qb;
        $qbAux->select('count(r.id)');
        $count = $qbAux->getQuery()->getSingleScalarResult();

        $qb->setFirstResult($start);
        $qb->setMaxResults($limit);

        $data = $qb->getQuery()->execute();
        return array('data' => $data, 'count' => $count);
    }
}
